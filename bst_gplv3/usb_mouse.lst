   1               		.file	"usb_mouse.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.usb_init,"ax",@progbits
  11               	.global	usb_init
  13               	usb_init:
  14               	.LFB1:
  15               		.file 1 "usb_mouse.c"
   1:usb_mouse.c   **** /* USB Mouse Plus Debug Channel Example for Teensy USB Development Board
   2:usb_mouse.c   ****  * http://www.pjrc.com/teensy/usb_mouse.html
   3:usb_mouse.c   ****  * Copyright (c) 2009 PJRC.COM, LLC
   4:usb_mouse.c   ****  *
   5:usb_mouse.c   ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   6:usb_mouse.c   ****  * of this software and associated documentation files (the "Software"), to deal
   7:usb_mouse.c   ****  * in the Software without restriction, including without limitation the rights
   8:usb_mouse.c   ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:usb_mouse.c   ****  * copies of the Software, and to permit persons to whom the Software is
  10:usb_mouse.c   ****  * furnished to do so, subject to the following conditions:
  11:usb_mouse.c   ****  *
  12:usb_mouse.c   ****  * The above copyright notice and this permission notice shall be included in
  13:usb_mouse.c   ****  * all copies or substantial portions of the Software.
  14:usb_mouse.c   ****  *
  15:usb_mouse.c   ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:usb_mouse.c   ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:usb_mouse.c   ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:usb_mouse.c   ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:usb_mouse.c   ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:usb_mouse.c   ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:usb_mouse.c   ****  * THE SOFTWARE.
  22:usb_mouse.c   ****  */
  23:usb_mouse.c   **** 
  24:usb_mouse.c   **** // Version 1.0: Initial Release
  25:usb_mouse.c   **** // Version 1.1: Add support for Teensy 2.0
  26:usb_mouse.c   **** 
  27:usb_mouse.c   **** // modified by Furiosus to support 16 bit motion data
  28:usb_mouse.c   **** // modified by qsxcv
  29:usb_mouse.c   **** 
  30:usb_mouse.c   **** #define USB_SERIAL_PRIVATE_INCLUDE
  31:usb_mouse.c   **** #include "usb_mouse.h"
  32:usb_mouse.c   **** 
  33:usb_mouse.c   **** /**************************************************************************
  34:usb_mouse.c   ****  *
  35:usb_mouse.c   ****  *  Configurable Options
  36:usb_mouse.c   ****  *
  37:usb_mouse.c   ****  **************************************************************************/
  38:usb_mouse.c   **** 
  39:usb_mouse.c   **** // You can change these to give your code its own name.
  40:usb_mouse.c   **** #define STR_MANUFACTURER	L"Bst"
  41:usb_mouse.c   **** #define STR_PRODUCT		L"Public"
  42:usb_mouse.c   **** 
  43:usb_mouse.c   **** 
  44:usb_mouse.c   **** // Mac OS-X and Linux automatically load the correct drivers.  On
  45:usb_mouse.c   **** // Windows, even though the driver is supplied by Microsoft, an
  46:usb_mouse.c   **** // INF file is needed to load the driver.  These numbers need to
  47:usb_mouse.c   **** // match the INF file.
  48:usb_mouse.c   **** #define VENDOR_ID		0x16C0
  49:usb_mouse.c   **** #define PRODUCT_ID		0x047E
  50:usb_mouse.c   **** 
  51:usb_mouse.c   **** 
  52:usb_mouse.c   **** // USB devices are supposed to implment a halt feature, which is
  53:usb_mouse.c   **** // rarely (if ever) used.  If you comment this line out, the halt
  54:usb_mouse.c   **** // code will be removed, saving 102 bytes of space (gcc 4.3.0).
  55:usb_mouse.c   **** // This is not strictly USB compliant, but works with all major
  56:usb_mouse.c   **** // operating systems.
  57:usb_mouse.c   **** #define SUPPORT_ENDPOINT_HALT
  58:usb_mouse.c   **** 
  59:usb_mouse.c   **** 
  60:usb_mouse.c   **** 
  61:usb_mouse.c   **** /**************************************************************************
  62:usb_mouse.c   ****  *
  63:usb_mouse.c   ****  *  Endpoint Buffer Configuration
  64:usb_mouse.c   ****  *
  65:usb_mouse.c   ****  **************************************************************************/
  66:usb_mouse.c   **** 
  67:usb_mouse.c   **** #define ENDPOINT0_SIZE		32
  68:usb_mouse.c   **** 
  69:usb_mouse.c   **** #define MOUSE_INTERFACE		0
  70:usb_mouse.c   **** //#define MOUSE_ENDPOINT	3 // moved to usb_mouse.h for use in main
  71:usb_mouse.c   **** #define MOUSE_SIZE		8
  72:usb_mouse.c   **** #define MOUSE_BUFFER		EP_SINGLE_BUFFER
  73:usb_mouse.c   **** 
  74:usb_mouse.c   **** static const uint8_t PROGMEM endpoint_config_table[] = {
  75:usb_mouse.c   **** 	0,
  76:usb_mouse.c   **** 	0,
  77:usb_mouse.c   **** 	1, EP_TYPE_INTERRUPT_IN,  EP_SIZE(MOUSE_SIZE) | MOUSE_BUFFER,
  78:usb_mouse.c   **** 	0
  79:usb_mouse.c   **** };
  80:usb_mouse.c   **** 
  81:usb_mouse.c   **** 
  82:usb_mouse.c   **** /**************************************************************************
  83:usb_mouse.c   ****  *
  84:usb_mouse.c   ****  *  Descriptor Data
  85:usb_mouse.c   ****  *
  86:usb_mouse.c   ****  **************************************************************************/
  87:usb_mouse.c   **** 
  88:usb_mouse.c   **** // Descriptors are the data that your computer reads when it auto-detects
  89:usb_mouse.c   **** // this USB device (called "enumeration" in USB lingo).  The most commonly
  90:usb_mouse.c   **** // changed items are editable at the top of this file.  Changing things
  91:usb_mouse.c   **** // in here should only be done by those who've read chapter 9 of the USB
  92:usb_mouse.c   **** // spec and relevant portions of any USB class specifications!
  93:usb_mouse.c   **** 
  94:usb_mouse.c   **** 
  95:usb_mouse.c   **** static const uint8_t PROGMEM device_descriptor[] = {
  96:usb_mouse.c   **** 	18,					// bLength
  97:usb_mouse.c   **** 	1,					// bDescriptorType
  98:usb_mouse.c   **** 	0x00, 0x02,				// bcdUSB
  99:usb_mouse.c   **** 	0,					// bDeviceClass
 100:usb_mouse.c   **** 	0,					// bDeviceSubClass
 101:usb_mouse.c   **** 	0,					// bDeviceProtocol
 102:usb_mouse.c   **** 	ENDPOINT0_SIZE,				// bMaxPacketSize0
 103:usb_mouse.c   **** 	LSB(VENDOR_ID), MSB(VENDOR_ID),		// idVendor
 104:usb_mouse.c   **** 	LSB(PRODUCT_ID), MSB(PRODUCT_ID),	// idProduct
 105:usb_mouse.c   **** 	0x00, 0x01,				// bcdDevice
 106:usb_mouse.c   **** 	1,					// iManufacturer
 107:usb_mouse.c   **** 	2,					// iProduct
 108:usb_mouse.c   **** 	0,					// iSerialNumber
 109:usb_mouse.c   **** 	1					// bNumConfigurations
 110:usb_mouse.c   **** };
 111:usb_mouse.c   **** 
 112:usb_mouse.c   **** // Mouse Protocol 1, HID 1.11 spec, Appendix B, page 59-60, with wheel extension
 113:usb_mouse.c   **** /*
 114:usb_mouse.c   **** static uint8_t PROGMEM mouse_hid_report_desc[] = {
 115:usb_mouse.c   **** 	0x05, 0x01,			// Usage Page (Generic Desktop)
 116:usb_mouse.c   **** 	0x09, 0x02,			// Usage (Mouse)
 117:usb_mouse.c   **** 	0xA1, 0x01,			// Collection (Application)
 118:usb_mouse.c   **** 	0x05, 0x09,			//   Usage Page (Button)
 119:usb_mouse.c   **** 	0x19, 0x01,			//   Usage Minimum (Button #1)
 120:usb_mouse.c   **** 	0x29, 0x03,			//   Usage Maximum (Button #3)
 121:usb_mouse.c   **** 	0x15, 0x00,			//   Logical Minimum (0)
 122:usb_mouse.c   **** 	0x25, 0x01,			//   Logical Maximum (1)
 123:usb_mouse.c   **** 	0x95, 0x03,			//   Report Count (3)
 124:usb_mouse.c   **** 	0x75, 0x01,			//   Report Size (1)
 125:usb_mouse.c   **** 	0x81, 0x02,			//   Input (Data, Variable, Absolute)
 126:usb_mouse.c   **** 	0x95, 0x01,			//   Report Count (1)
 127:usb_mouse.c   **** 	0x75, 0x05,			//   Report Size (5)
 128:usb_mouse.c   **** 	0x81, 0x03,			//   Input (Constant)
 129:usb_mouse.c   **** 	0x05, 0x01,			//   Usage Page (Generic Desktop)
 130:usb_mouse.c   **** 	0x09, 0x30,			//   Usage (X)
 131:usb_mouse.c   **** 	0x09, 0x31,			//   Usage (Y)
 132:usb_mouse.c   **** 	0x15, 0x80,			//   Logical Minimum (-128)
 133:usb_mouse.c   **** 	0x25, 0x7F,			//   Logical Maximum (127)
 134:usb_mouse.c   **** 	0x75, 0x08,			//   Report Size (8),
 135:usb_mouse.c   **** 	0x95, 0x02,			//   Report Count (2),
 136:usb_mouse.c   **** 	0x81, 0x06,			//   Input (Data, Variable, Relative)
 137:usb_mouse.c   **** 	0x09, 0x38,			//   Usage (Wheel)
 138:usb_mouse.c   **** 	0x95, 0x01,			//   Report Count (1),
 139:usb_mouse.c   **** 	0x81, 0x06,			//   Input (Data, Variable, Relative)
 140:usb_mouse.c   **** 	0xC0				// End Collection
 141:usb_mouse.c   **** };
 142:usb_mouse.c   **** */
 143:usb_mouse.c   **** static const uint8_t PROGMEM mouse_hid_report_desc[] = {
 144:usb_mouse.c   **** 	0x05, 0x01,		// Usage Page (Generic Desktop)
 145:usb_mouse.c   **** 	0x09, 0x02,		// Usage (Mouse)
 146:usb_mouse.c   **** 	0xA1, 0x01,		// Collection (Application)
 147:usb_mouse.c   **** 	0x05, 0x09,		//   Usage Page (Button)
 148:usb_mouse.c   **** 	0x19, 0x01,		//   Usage Minimum (Button #1)
 149:usb_mouse.c   **** 	0x29, 0x05,		//   Usage Maximum (Button #5)
 150:usb_mouse.c   **** 	0x15, 0x00,		//   Logical Minimum (0)
 151:usb_mouse.c   **** 	0x25, 0x01,		//   Logical Maximum (1)
 152:usb_mouse.c   **** 	0x95, 0x05,		//   Report Count (5)
 153:usb_mouse.c   **** 	0x75, 0x01,		//   Report Size (1)
 154:usb_mouse.c   **** 	0x81, 0x02,		//   Input (Data, Variable, Absolute)
 155:usb_mouse.c   **** 	0x95, 0x01,		//   Report Count (1)
 156:usb_mouse.c   **** 	0x75, 0x03,		//   Report Size (3)
 157:usb_mouse.c   **** 	0x81, 0x03,		//   Input (Constant) // Byte 1
 158:usb_mouse.c   **** 	0x05, 0x01,		//   Usage Page (Generic Desktop)
 159:usb_mouse.c   **** 	0x09, 0x30,		//   Usage (X)
 160:usb_mouse.c   **** 	0x09, 0x31,		//   Usage (Y)
 161:usb_mouse.c   **** 	0x16, 0x01, 0x80,	//   Logical Minimum (-32,767)
 162:usb_mouse.c   **** 	0x26, 0xFF, 0x7F,	//   Logical Maximum (32,767)
 163:usb_mouse.c   **** 	0x36, 0x01, 0x80,	//   Physical Minimum (-32,767)
 164:usb_mouse.c   **** 	0x46, 0xFF, 0x7F,	//   Physical Maxiumum (32,767)
 165:usb_mouse.c   **** 	0x75, 0x10,		//   Report Size (16),
 166:usb_mouse.c   **** 	0x95, 0x02,		//   Report Count (2),
 167:usb_mouse.c   **** 	0x81, 0x06,		//   Input (Data, Variable, Relative) // Byte 3, 5
 168:usb_mouse.c   **** 	0x09, 0x38,		//   Usage (Wheel)
 169:usb_mouse.c   **** 	0x15, 0x81,		//   Logical Minimum (-127)
 170:usb_mouse.c   **** 	0x25, 0x7F,		//   Logical Maximum (127)
 171:usb_mouse.c   **** 	0x35, 0x81,		//   Phyiscal Minimum (-127)
 172:usb_mouse.c   **** 	0x45, 0x7F,		//   Physical Maxiumum (127)
 173:usb_mouse.c   **** 	0x75, 0x08,		//   Report Size (8)
 174:usb_mouse.c   **** 	0x95, 0x01,		//   Report Count (1)
 175:usb_mouse.c   **** 	0x81, 0x06,		//   Input (Data, Variable, Relative) // Byte 6
 176:usb_mouse.c   **** 	0xC0			// End Collection
 177:usb_mouse.c   **** };
 178:usb_mouse.c   **** 
 179:usb_mouse.c   **** #define CONFIG1_DESC_SIZE        (9+9+9+7)
 180:usb_mouse.c   **** #define MOUSE_HID_DESC_OFFSET    (9+9)
 181:usb_mouse.c   **** static const uint8_t PROGMEM config1_descriptor[CONFIG1_DESC_SIZE] = {
 182:usb_mouse.c   **** 	// configuration descriptor, USB spec 9.6.3, page 264-266, Table 9-10
 183:usb_mouse.c   **** 	9, 					// bLength;
 184:usb_mouse.c   **** 	2,					// bDescriptorType;
 185:usb_mouse.c   **** 	LSB(CONFIG1_DESC_SIZE),			// wTotalLength
 186:usb_mouse.c   **** 	MSB(CONFIG1_DESC_SIZE),
 187:usb_mouse.c   **** 	1,					// bNumInterfaces
 188:usb_mouse.c   **** 	1,					// bConfigurationValue
 189:usb_mouse.c   **** 	0,					// iConfiguration
 190:usb_mouse.c   **** 	0xC0,					// bmAttributes
 191:usb_mouse.c   **** 	50,					// bMaxPower
 192:usb_mouse.c   **** 	// interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
 193:usb_mouse.c   **** 	9,					// bLength
 194:usb_mouse.c   **** 	4,					// bDescriptorType
 195:usb_mouse.c   **** 	MOUSE_INTERFACE,			// bInterfaceNumber
 196:usb_mouse.c   **** 	0,					// bAlternateSetting
 197:usb_mouse.c   **** 	1,					// bNumEndpoints
 198:usb_mouse.c   **** 	0x03,					// bInterfaceClass (0x03 = HID)
 199:usb_mouse.c   **** 	0x01,					// bInterfaceSubClass (0x01 = Boot)
 200:usb_mouse.c   **** 	0x02,					// bInterfaceProtocol (0x02 = Mouse)
 201:usb_mouse.c   **** 	0,					// iInterface
 202:usb_mouse.c   **** 	// HID interface descriptor, HID 1.11 spec, section 6.2.1
 203:usb_mouse.c   **** 	9,					// bLength
 204:usb_mouse.c   **** 	0x21,					// bDescriptorType
 205:usb_mouse.c   **** 	0x11, 0x01,				// bcdHID
 206:usb_mouse.c   **** 	0,					// bCountryCode
 207:usb_mouse.c   **** 	1,					// bNumDescriptors
 208:usb_mouse.c   **** 	0x22,					// bDescriptorType
 209:usb_mouse.c   **** 	sizeof(mouse_hid_report_desc),		// wDescriptorLength
 210:usb_mouse.c   **** 	0,
 211:usb_mouse.c   **** 	// endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
 212:usb_mouse.c   **** 	7,					// bLength
 213:usb_mouse.c   **** 	5,					// bDescriptorType
 214:usb_mouse.c   **** 	MOUSE_ENDPOINT | 0x80,			// bEndpointAddress
 215:usb_mouse.c   **** 	0x03,					// bmAttributes (0x03=intr)
 216:usb_mouse.c   **** 	6, 0,					// wMaxPacketSize
 217:usb_mouse.c   **** 	1					// bInterval **** USB POLLING RATE ****
 218:usb_mouse.c   **** };
 219:usb_mouse.c   **** 
 220:usb_mouse.c   **** // If you're desperate for a little extra code memory, these strings
 221:usb_mouse.c   **** // can be completely removed if iManufacturer, iProduct, iSerialNumber
 222:usb_mouse.c   **** // in the device desciptor are changed to zeros.
 223:usb_mouse.c   **** struct usb_string_descriptor_struct {
 224:usb_mouse.c   **** 	uint8_t bLength;
 225:usb_mouse.c   **** 	uint8_t bDescriptorType;
 226:usb_mouse.c   **** 	int16_t wString[];
 227:usb_mouse.c   **** };
 228:usb_mouse.c   **** static const struct usb_string_descriptor_struct PROGMEM string0 = {
 229:usb_mouse.c   **** 	4,
 230:usb_mouse.c   **** 	3,
 231:usb_mouse.c   **** 	{0x0409}
 232:usb_mouse.c   **** };
 233:usb_mouse.c   **** static const struct usb_string_descriptor_struct PROGMEM string1 = {
 234:usb_mouse.c   **** 	sizeof(STR_MANUFACTURER),
 235:usb_mouse.c   **** 	3,
 236:usb_mouse.c   **** 	STR_MANUFACTURER
 237:usb_mouse.c   **** };
 238:usb_mouse.c   **** static const struct usb_string_descriptor_struct PROGMEM string2 = {
 239:usb_mouse.c   **** 	sizeof(STR_PRODUCT),
 240:usb_mouse.c   **** 	3,
 241:usb_mouse.c   **** 	STR_PRODUCT
 242:usb_mouse.c   **** };
 243:usb_mouse.c   **** 
 244:usb_mouse.c   **** // This table defines which descriptor data is sent for each specific
 245:usb_mouse.c   **** // request from the host (in wValue and wIndex).
 246:usb_mouse.c   **** static const struct descriptor_list_struct {
 247:usb_mouse.c   **** 	uint16_t	wValue;
 248:usb_mouse.c   **** 	uint16_t	wIndex;
 249:usb_mouse.c   **** 	const uint8_t	*addr;
 250:usb_mouse.c   **** 	uint8_t		length;
 251:usb_mouse.c   **** } PROGMEM descriptor_list[] = {
 252:usb_mouse.c   **** 	{0x0100, 0x0000, device_descriptor, sizeof(device_descriptor)},
 253:usb_mouse.c   **** 	{0x0200, 0x0000, config1_descriptor, sizeof(config1_descriptor)},
 254:usb_mouse.c   **** 	{0x2200, MOUSE_INTERFACE, mouse_hid_report_desc, sizeof(mouse_hid_report_desc)},
 255:usb_mouse.c   **** 	{0x2100, MOUSE_INTERFACE, config1_descriptor+MOUSE_HID_DESC_OFFSET, 9},
 256:usb_mouse.c   **** 	{0x0300, 0x0000, (const uint8_t *)&string0, 4},
 257:usb_mouse.c   **** 	{0x0301, 0x0409, (const uint8_t *)&string1, sizeof(STR_MANUFACTURER)},
 258:usb_mouse.c   **** 	{0x0302, 0x0409, (const uint8_t *)&string2, sizeof(STR_PRODUCT)}
 259:usb_mouse.c   **** };
 260:usb_mouse.c   **** #define NUM_DESC_LIST (sizeof(descriptor_list)/sizeof(struct descriptor_list_struct))
 261:usb_mouse.c   **** 
 262:usb_mouse.c   **** 
 263:usb_mouse.c   **** /**************************************************************************
 264:usb_mouse.c   ****  *
 265:usb_mouse.c   ****  *  Variables - these are the only non-stack RAM usage
 266:usb_mouse.c   ****  *
 267:usb_mouse.c   ****  **************************************************************************/
 268:usb_mouse.c   **** 
 269:usb_mouse.c   **** // zero when we are not configured, non-zero when enumerated
 270:usb_mouse.c   **** static volatile uint8_t usb_configuration=0;
 271:usb_mouse.c   **** 
 272:usb_mouse.c   **** // protocol setting from the host.  We use exactly the same report
 273:usb_mouse.c   **** // either way, so this variable only stores the setting since we
 274:usb_mouse.c   **** // are required to be able to report which setting is in use.
 275:usb_mouse.c   **** static uint8_t mouse_protocol=1;
 276:usb_mouse.c   **** 
 277:usb_mouse.c   **** 
 278:usb_mouse.c   **** /**************************************************************************
 279:usb_mouse.c   ****  *
 280:usb_mouse.c   ****  *  Public Functions - these are the API intended for the user
 281:usb_mouse.c   ****  *
 282:usb_mouse.c   ****  **************************************************************************/
 283:usb_mouse.c   **** 
 284:usb_mouse.c   **** 
 285:usb_mouse.c   **** // initialize USB
 286:usb_mouse.c   **** void usb_init(void)
 287:usb_mouse.c   **** {
  16               		.loc 1 287 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 288:usb_mouse.c   **** 	HW_CONFIG();
  22               		.loc 1 288 0
  23 0000 81E0      		ldi r24,lo8(1)
  24 0002 8093 D700 		sts 215,r24
 289:usb_mouse.c   **** 	USB_FREEZE();				// enable USB
  25               		.loc 1 289 0
  26 0006 80EA      		ldi r24,lo8(-96)
  27 0008 8093 D800 		sts 216,r24
 290:usb_mouse.c   **** 	PLL_CONFIG();				// config PLL
  28               		.loc 1 290 0
  29 000c 82E1      		ldi r24,lo8(18)
  30 000e 89BD      		out 0x29,r24
  31               	.L2:
 291:usb_mouse.c   ****         while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
  32               		.loc 1 291 0 discriminator 1
  33 0010 09B4      		in __tmp_reg__,0x29
  34 0012 00FE      		sbrs __tmp_reg__,0
  35 0014 00C0      		rjmp .L2
 292:usb_mouse.c   ****         USB_CONFIG();				// start USB clock
  36               		.loc 1 292 0
  37 0016 80E9      		ldi r24,lo8(-112)
  38 0018 8093 D800 		sts 216,r24
 293:usb_mouse.c   ****         UDCON = 0;				// enable attach resistor
  39               		.loc 1 293 0
  40 001c 1092 E000 		sts 224,__zero_reg__
 294:usb_mouse.c   **** 	usb_configuration = 0;
  41               		.loc 1 294 0
  42 0020 1092 0000 		sts usb_configuration,__zero_reg__
 295:usb_mouse.c   ****         UDIEN = (1<<EORSTE);
  43               		.loc 1 295 0
  44 0024 88E0      		ldi r24,lo8(8)
  45 0026 8093 E200 		sts 226,r24
 296:usb_mouse.c   **** 	sei();
  46               		.loc 1 296 0
  47               	/* #APP */
  48               	 ;  296 "usb_mouse.c" 1
  49 002a 7894      		sei
  50               	 ;  0 "" 2
  51               	/* #NOAPP */
  52 002c 0895      		ret
  53               		.cfi_endproc
  54               	.LFE1:
  56               		.section	.text.usb_configured,"ax",@progbits
  57               	.global	usb_configured
  59               	usb_configured:
  60               	.LFB2:
 297:usb_mouse.c   **** }
 298:usb_mouse.c   **** 
 299:usb_mouse.c   **** // return 0 if the USB is not configured, or the configuration
 300:usb_mouse.c   **** // number selected by the HOST
 301:usb_mouse.c   **** uint8_t usb_configured(void)
 302:usb_mouse.c   **** {
  61               		.loc 1 302 0
  62               		.cfi_startproc
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 0 */
  66               	.L__stack_usage = 0
 303:usb_mouse.c   **** 	return usb_configuration;
  67               		.loc 1 303 0
  68 0000 8091 0000 		lds r24,usb_configuration
 304:usb_mouse.c   **** }
  69               		.loc 1 304 0
  70 0004 0895      		ret
  71               		.cfi_endproc
  72               	.LFE2:
  74               		.section	.text.__vector_10,"ax",@progbits
  75               	.global	__vector_10
  77               	__vector_10:
  78               	.LFB3:
 305:usb_mouse.c   **** 
 306:usb_mouse.c   **** 
 307:usb_mouse.c   **** /*
 308:usb_mouse.c   **** void usb_mouse_update(const uint8_t button_mask, // 0th (least significant) bit = left, 1th bit = r
 309:usb_mouse.c   **** 		const uint8_t x_lo, const uint8_t x_hi,
 310:usb_mouse.c   **** 		const uint8_t y_lo, const uint8_t y_hi,
 311:usb_mouse.c   **** 		const int8_t wheel)
 312:usb_mouse.c   **** {
 313:usb_mouse.c   **** 	uint8_t intr_state, timeout;
 314:usb_mouse.c   **** 
 315:usb_mouse.c   **** 	if (!usb_configuration) return;
 316:usb_mouse.c   **** 	intr_state = SREG;
 317:usb_mouse.c   **** 	cli();
 318:usb_mouse.c   **** 	UENUM = MOUSE_ENDPOINT;
 319:usb_mouse.c   **** 	timeout = UDFNUML + 50;
 320:usb_mouse.c   **** 	while (1) {
 321:usb_mouse.c   **** 		// are we ready to transmit?
 322:usb_mouse.c   **** 		if (UEINTX & (1<<RWAL)) break;
 323:usb_mouse.c   **** 		SREG = intr_state;
 324:usb_mouse.c   **** 		// has the USB gone offline?
 325:usb_mouse.c   **** 		if (!usb_configuration) return;
 326:usb_mouse.c   **** 		// have we waited too long?
 327:usb_mouse.c   **** 		if (UDFNUML == timeout) return;
 328:usb_mouse.c   **** 		// get ready to try checking again
 329:usb_mouse.c   **** 		intr_state = SREG;
 330:usb_mouse.c   **** 		cli();
 331:usb_mouse.c   **** 		UENUM = MOUSE_ENDPOINT;
 332:usb_mouse.c   **** 	}
 333:usb_mouse.c   **** 	UEDATX = button_mask;
 334:usb_mouse.c   **** 	UEDATX = x_lo;
 335:usb_mouse.c   **** 	UEDATX = x_hi;
 336:usb_mouse.c   **** 	UEDATX = y_lo;
 337:usb_mouse.c   **** 	UEDATX = y_hi;
 338:usb_mouse.c   **** 	UEDATX = wheel;
 339:usb_mouse.c   **** 	UEINTX = 0x3A;
 340:usb_mouse.c   **** 	SREG = intr_state;
 341:usb_mouse.c   **** }
 342:usb_mouse.c   **** */
 343:usb_mouse.c   **** 
 344:usb_mouse.c   **** /**************************************************************************
 345:usb_mouse.c   ****  *
 346:usb_mouse.c   ****  *  Private Functions - not intended for general user consumption....
 347:usb_mouse.c   ****  *
 348:usb_mouse.c   ****  **************************************************************************/
 349:usb_mouse.c   **** 
 350:usb_mouse.c   **** 
 351:usb_mouse.c   **** 
 352:usb_mouse.c   **** // USB Device Interrupt - handle all device-level events
 353:usb_mouse.c   **** // the transmit buffer flushing is triggered by the start of frame
 354:usb_mouse.c   **** //
 355:usb_mouse.c   **** ISR(USB_GEN_vect)
 356:usb_mouse.c   **** {
  79               		.loc 1 356 0
  80               		.cfi_startproc
  81 0000 1F92      		push r1
  82               	.LCFI0:
  83               		.cfi_def_cfa_offset 3
  84               		.cfi_offset 1, -2
  85 0002 0F92      		push r0
  86               	.LCFI1:
  87               		.cfi_def_cfa_offset 4
  88               		.cfi_offset 0, -3
  89 0004 0FB6      		in r0,__SREG__
  90 0006 0F92      		push r0
  91 0008 1124      		clr __zero_reg__
  92 000a 8F93      		push r24
  93               	.LCFI2:
  94               		.cfi_def_cfa_offset 5
  95               		.cfi_offset 24, -4
  96               	/* prologue: Signal */
  97               	/* frame size = 0 */
  98               	/* stack size = 4 */
  99               	.L__stack_usage = 4
 357:usb_mouse.c   **** 	uint8_t intbits;
 358:usb_mouse.c   **** 
 359:usb_mouse.c   ****         intbits = UDINT;
 100               		.loc 1 359 0
 101 000c 8091 E100 		lds r24,225
 102               	.LVL0:
 360:usb_mouse.c   ****         UDINT = 0;
 103               		.loc 1 360 0
 104 0010 1092 E100 		sts 225,__zero_reg__
 361:usb_mouse.c   ****         if (intbits & (1<<EORSTI)) {
 105               		.loc 1 361 0
 106 0014 83FF      		sbrs r24,3
 107 0016 00C0      		rjmp .L7
 362:usb_mouse.c   **** 		UENUM = 0;
 108               		.loc 1 362 0
 109 0018 1092 E900 		sts 233,__zero_reg__
 363:usb_mouse.c   **** 		UECONX = 1;
 110               		.loc 1 363 0
 111 001c 81E0      		ldi r24,lo8(1)
 112               	.LVL1:
 113 001e 8093 EB00 		sts 235,r24
 364:usb_mouse.c   **** 		UECFG0X = EP_TYPE_CONTROL;
 114               		.loc 1 364 0
 115 0022 1092 EC00 		sts 236,__zero_reg__
 365:usb_mouse.c   **** 		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 116               		.loc 1 365 0
 117 0026 82E2      		ldi r24,lo8(34)
 118 0028 8093 ED00 		sts 237,r24
 366:usb_mouse.c   **** 		UEIENX = (1<<RXSTPE);
 119               		.loc 1 366 0
 120 002c 88E0      		ldi r24,lo8(8)
 121 002e 8093 F000 		sts 240,r24
 367:usb_mouse.c   **** 		usb_configuration = 0;
 122               		.loc 1 367 0
 123 0032 1092 0000 		sts usb_configuration,__zero_reg__
 124               	.L7:
 125               	/* epilogue start */
 368:usb_mouse.c   ****         }
 369:usb_mouse.c   **** }
 126               		.loc 1 369 0
 127 0036 8F91      		pop r24
 128 0038 0F90      		pop r0
 129 003a 0FBE      		out __SREG__,r0
 130 003c 0F90      		pop r0
 131 003e 1F90      		pop r1
 132 0040 1895      		reti
 133               		.cfi_endproc
 134               	.LFE3:
 136               		.section	.text.__vector_11,"ax",@progbits
 137               	.global	__vector_11
 139               	__vector_11:
 140               	.LFB8:
 370:usb_mouse.c   **** 
 371:usb_mouse.c   **** 
 372:usb_mouse.c   **** 
 373:usb_mouse.c   **** // Misc functions to wait for ready and send/receive packets
 374:usb_mouse.c   **** static inline void usb_wait_in_ready(void)
 375:usb_mouse.c   **** {
 376:usb_mouse.c   **** 	while (!(UEINTX & (1<<TXINI))) ;
 377:usb_mouse.c   **** }
 378:usb_mouse.c   **** static inline void usb_send_in(void)
 379:usb_mouse.c   **** {
 380:usb_mouse.c   **** 	UEINTX = ~(1<<TXINI);
 381:usb_mouse.c   **** }
 382:usb_mouse.c   **** static inline void usb_wait_receive_out(void)
 383:usb_mouse.c   **** {
 384:usb_mouse.c   **** 	while (!(UEINTX & (1<<RXOUTI))) ;
 385:usb_mouse.c   **** }
 386:usb_mouse.c   **** static inline void usb_ack_out(void)
 387:usb_mouse.c   **** {
 388:usb_mouse.c   **** 	UEINTX = ~(1<<RXOUTI);
 389:usb_mouse.c   **** }
 390:usb_mouse.c   **** 
 391:usb_mouse.c   **** 
 392:usb_mouse.c   **** 
 393:usb_mouse.c   **** // USB Endpoint Interrupt - endpoint 0 is handled here.  The
 394:usb_mouse.c   **** // other endpoints are manipulated by the user-callable
 395:usb_mouse.c   **** // functions, and the start-of-frame interrupt.
 396:usb_mouse.c   **** //
 397:usb_mouse.c   **** ISR(USB_COM_vect)
 398:usb_mouse.c   **** {
 141               		.loc 1 398 0
 142               		.cfi_startproc
 143 0000 1F92      		push r1
 144               	.LCFI3:
 145               		.cfi_def_cfa_offset 3
 146               		.cfi_offset 1, -2
 147 0002 0F92      		push r0
 148               	.LCFI4:
 149               		.cfi_def_cfa_offset 4
 150               		.cfi_offset 0, -3
 151 0004 0FB6      		in r0,__SREG__
 152 0006 0F92      		push r0
 153 0008 1124      		clr __zero_reg__
 154 000a 2F93      		push r18
 155               	.LCFI5:
 156               		.cfi_def_cfa_offset 5
 157               		.cfi_offset 18, -4
 158 000c 3F93      		push r19
 159               	.LCFI6:
 160               		.cfi_def_cfa_offset 6
 161               		.cfi_offset 19, -5
 162 000e 4F93      		push r20
 163               	.LCFI7:
 164               		.cfi_def_cfa_offset 7
 165               		.cfi_offset 20, -6
 166 0010 5F93      		push r21
 167               	.LCFI8:
 168               		.cfi_def_cfa_offset 8
 169               		.cfi_offset 21, -7
 170 0012 6F93      		push r22
 171               	.LCFI9:
 172               		.cfi_def_cfa_offset 9
 173               		.cfi_offset 22, -8
 174 0014 7F93      		push r23
 175               	.LCFI10:
 176               		.cfi_def_cfa_offset 10
 177               		.cfi_offset 23, -9
 178 0016 8F93      		push r24
 179               	.LCFI11:
 180               		.cfi_def_cfa_offset 11
 181               		.cfi_offset 24, -10
 182 0018 9F93      		push r25
 183               	.LCFI12:
 184               		.cfi_def_cfa_offset 12
 185               		.cfi_offset 25, -11
 186 001a AF93      		push r26
 187               	.LCFI13:
 188               		.cfi_def_cfa_offset 13
 189               		.cfi_offset 26, -12
 190 001c BF93      		push r27
 191               	.LCFI14:
 192               		.cfi_def_cfa_offset 14
 193               		.cfi_offset 27, -13
 194 001e CF93      		push r28
 195               	.LCFI15:
 196               		.cfi_def_cfa_offset 15
 197               		.cfi_offset 28, -14
 198 0020 EF93      		push r30
 199               	.LCFI16:
 200               		.cfi_def_cfa_offset 16
 201               		.cfi_offset 30, -15
 202 0022 FF93      		push r31
 203               	.LCFI17:
 204               		.cfi_def_cfa_offset 17
 205               		.cfi_offset 31, -16
 206               	/* prologue: Signal */
 207               	/* frame size = 0 */
 208               	/* stack size = 16 */
 209               	.L__stack_usage = 16
 399:usb_mouse.c   ****         uint8_t intbits;
 400:usb_mouse.c   **** 	const uint8_t *list;
 401:usb_mouse.c   ****         const uint8_t *cfg;
 402:usb_mouse.c   **** 	uint8_t i, n, len, en;
 403:usb_mouse.c   **** 	uint8_t bmRequestType;
 404:usb_mouse.c   **** 	uint8_t bRequest;
 405:usb_mouse.c   **** 	uint16_t wValue;
 406:usb_mouse.c   **** 	uint16_t wIndex;
 407:usb_mouse.c   **** 	uint16_t wLength;
 408:usb_mouse.c   **** 	uint16_t desc_val;
 409:usb_mouse.c   **** 	const uint8_t *desc_addr;
 410:usb_mouse.c   **** 	uint8_t	desc_length;
 411:usb_mouse.c   **** 
 412:usb_mouse.c   ****         UENUM = 0;
 210               		.loc 1 412 0
 211 0024 1092 E900 		sts 233,__zero_reg__
 413:usb_mouse.c   **** 	intbits = UEINTX;
 212               		.loc 1 413 0
 213 0028 8091 E800 		lds r24,232
 214               	.LVL2:
 414:usb_mouse.c   ****         if (intbits & (1<<RXSTPI)) {
 215               		.loc 1 414 0
 216 002c 83FF      		sbrs r24,3
 217 002e 00C0      		rjmp .L13
 415:usb_mouse.c   ****                 bmRequestType = UEDATX;
 218               		.loc 1 415 0
 219 0030 6091 F100 		lds r22,241
 220               	.LVL3:
 416:usb_mouse.c   ****                 bRequest = UEDATX;
 221               		.loc 1 416 0
 222 0034 8091 F100 		lds r24,241
 223               	.LVL4:
 417:usb_mouse.c   ****                 wValue = UEDATX;
 224               		.loc 1 417 0
 225 0038 2091 F100 		lds r18,241
 226               	.LVL5:
 418:usb_mouse.c   ****                 wValue |= (UEDATX << 8);
 227               		.loc 1 418 0
 228 003c 9091 F100 		lds r25,241
 229 0040 30E0      		ldi r19,0
 230 0042 392B      		or r19,r25
 231               	.LVL6:
 419:usb_mouse.c   ****                 wIndex = UEDATX;
 232               		.loc 1 419 0
 233 0044 4091 F100 		lds r20,241
 234               	.LVL7:
 420:usb_mouse.c   ****                 wIndex |= (UEDATX << 8);
 235               		.loc 1 420 0
 236 0048 9091 F100 		lds r25,241
 237 004c 50E0      		ldi r21,0
 238 004e 592B      		or r21,r25
 239               	.LVL8:
 421:usb_mouse.c   ****                 wLength = UEDATX;
 240               		.loc 1 421 0
 241 0050 7091 F100 		lds r23,241
 242               	.LVL9:
 422:usb_mouse.c   ****                 wLength |= (UEDATX << 8);
 243               		.loc 1 422 0
 244 0054 C091 F100 		lds r28,241
 245               	.LVL10:
 423:usb_mouse.c   ****                 UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 246               		.loc 1 423 0
 247 0058 92EF      		ldi r25,lo8(-14)
 248 005a 9093 E800 		sts 232,r25
 424:usb_mouse.c   ****                 if (bRequest == GET_DESCRIPTOR) {
 249               		.loc 1 424 0
 250 005e 8630      		cpi r24,lo8(6)
 251 0060 01F0      		breq .L74
 425:usb_mouse.c   **** 			list = (const uint8_t *)descriptor_list;
 426:usb_mouse.c   **** 			for (i=0; ; i++) {
 427:usb_mouse.c   **** 				if (i >= NUM_DESC_LIST) {
 428:usb_mouse.c   **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
 429:usb_mouse.c   **** 					return;
 430:usb_mouse.c   **** 				}
 431:usb_mouse.c   **** 				desc_val = pgm_read_word(list);
 432:usb_mouse.c   **** 				if (desc_val != wValue) {
 433:usb_mouse.c   **** 					list += sizeof(struct descriptor_list_struct);
 434:usb_mouse.c   **** 					continue;
 435:usb_mouse.c   **** 				}
 436:usb_mouse.c   **** 				list += 2;
 437:usb_mouse.c   **** 				desc_val = pgm_read_word(list);
 438:usb_mouse.c   **** 				if (desc_val != wIndex) {
 439:usb_mouse.c   **** 					list += sizeof(struct descriptor_list_struct)-2;
 440:usb_mouse.c   **** 					continue;
 441:usb_mouse.c   **** 				}
 442:usb_mouse.c   **** 				list += 2;
 443:usb_mouse.c   **** 				desc_addr = (const uint8_t *)pgm_read_word(list);
 444:usb_mouse.c   **** 				list += 2;
 445:usb_mouse.c   **** 				desc_length = pgm_read_byte(list);
 446:usb_mouse.c   **** 				break;
 447:usb_mouse.c   **** 			}
 448:usb_mouse.c   **** 			len = (wLength < 256) ? wLength : 255;
 449:usb_mouse.c   **** 			if (len > desc_length) len = desc_length;
 450:usb_mouse.c   **** 			do {
 451:usb_mouse.c   **** 				// wait for host ready for IN packet
 452:usb_mouse.c   **** 				do {
 453:usb_mouse.c   **** 					i = UEINTX;
 454:usb_mouse.c   **** 				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 455:usb_mouse.c   **** 				if (i & (1<<RXOUTI)) return;	// abort
 456:usb_mouse.c   **** 				// send IN packet
 457:usb_mouse.c   **** 				n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 458:usb_mouse.c   **** 				for (i = n; i; i--) {
 459:usb_mouse.c   **** 					UEDATX = pgm_read_byte(desc_addr++);
 460:usb_mouse.c   **** 				}
 461:usb_mouse.c   **** 				len -= n;
 462:usb_mouse.c   **** 				usb_send_in();
 463:usb_mouse.c   **** 			} while (len || n == ENDPOINT0_SIZE);
 464:usb_mouse.c   **** 			return;
 465:usb_mouse.c   ****                 }
 466:usb_mouse.c   **** 		if (bRequest == SET_ADDRESS) {
 252               		.loc 1 466 0
 253 0062 8530      		cpi r24,lo8(5)
 254 0064 01F4      		brne .+2
 255 0066 00C0      		rjmp .L75
 467:usb_mouse.c   **** 			usb_send_in();
 468:usb_mouse.c   **** 			usb_wait_in_ready();
 469:usb_mouse.c   **** 			UDADDR = wValue | (1<<ADDEN);
 470:usb_mouse.c   **** 			return;
 471:usb_mouse.c   **** 		}
 472:usb_mouse.c   **** 		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
 256               		.loc 1 472 0
 257 0068 8930      		cpi r24,lo8(9)
 258 006a 01F0      		breq .L76
 473:usb_mouse.c   **** 			usb_configuration = wValue;
 474:usb_mouse.c   **** 			usb_send_in();
 475:usb_mouse.c   **** 			cfg = endpoint_config_table;
 476:usb_mouse.c   **** 			for (i=1; i<5; i++) {
 477:usb_mouse.c   **** 				UENUM = i;
 478:usb_mouse.c   **** 				en = pgm_read_byte(cfg++);
 479:usb_mouse.c   **** 				UECONX = en;
 480:usb_mouse.c   **** 				if (en) {
 481:usb_mouse.c   **** 					UECFG0X = pgm_read_byte(cfg++);
 482:usb_mouse.c   **** 					UECFG1X = pgm_read_byte(cfg++);
 483:usb_mouse.c   **** 				}
 484:usb_mouse.c   **** 			}
 485:usb_mouse.c   ****         		UERST = 0x1E;
 486:usb_mouse.c   ****         		UERST = 0;
 487:usb_mouse.c   **** 			return;
 488:usb_mouse.c   **** 		}
 489:usb_mouse.c   **** 		if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {
 259               		.loc 1 489 0
 260 006c 8830      		cpi r24,lo8(8)
 261 006e 01F4      		brne .+2
 262 0070 00C0      		rjmp .L77
 490:usb_mouse.c   **** 			usb_wait_in_ready();
 491:usb_mouse.c   **** 			UEDATX = usb_configuration;
 492:usb_mouse.c   **** 			usb_send_in();
 493:usb_mouse.c   **** 			return;
 494:usb_mouse.c   **** 		}
 495:usb_mouse.c   **** 
 496:usb_mouse.c   **** 		if (bRequest == GET_STATUS) {
 263               		.loc 1 496 0
 264 0072 8111      		cpse r24,__zero_reg__
 265 0074 00C0      		rjmp .L39
 266               	.LVL11:
 267               	.L40:
 268               	.LBB38:
 269               	.LBB39:
 376:usb_mouse.c   **** }
 270               		.loc 1 376 0
 271 0076 8091 E800 		lds r24,232
 272 007a 80FF      		sbrs r24,0
 273 007c 00C0      		rjmp .L40
 274               	.LVL12:
 275               	.LBE39:
 276               	.LBE38:
 497:usb_mouse.c   **** 			usb_wait_in_ready();
 498:usb_mouse.c   **** 			i = 0;
 499:usb_mouse.c   **** 			#ifdef SUPPORT_ENDPOINT_HALT
 500:usb_mouse.c   **** 			if (bmRequestType == 0x82) {
 277               		.loc 1 500 0
 278 007e 6238      		cpi r22,lo8(-126)
 279 0080 01F4      		brne .+2
 280 0082 00C0      		rjmp .L78
 498:usb_mouse.c   **** 			#ifdef SUPPORT_ENDPOINT_HALT
 281               		.loc 1 498 0
 282 0084 80E0      		ldi r24,0
 283               	.LVL13:
 284               	.L41:
 501:usb_mouse.c   **** 				UENUM = wIndex;
 502:usb_mouse.c   **** 				if (UECONX & (1<<STALLRQ)) i = 1;
 503:usb_mouse.c   **** 				UENUM = 0;
 504:usb_mouse.c   **** 			}
 505:usb_mouse.c   **** 			#endif
 506:usb_mouse.c   **** 			UEDATX = i;
 285               		.loc 1 506 0
 286 0086 8093 F100 		sts 241,r24
 507:usb_mouse.c   **** 			UEDATX = 0;
 287               		.loc 1 507 0
 288 008a 1092 F100 		sts 241,__zero_reg__
 289               	.LBB40:
 290               	.LBB41:
 380:usb_mouse.c   **** }
 291               		.loc 1 380 0
 292 008e 8EEF      		ldi r24,lo8(-2)
 293               	.LVL14:
 294 0090 8093 E800 		sts 232,r24
 295 0094 00C0      		rjmp .L12
 296               	.LVL15:
 297               	.L74:
 298               	.LBE41:
 299               	.LBE40:
 300 0096 67E0      		ldi r22,lo8(7)
 301               	.LVL16:
 302 0098 80E0      		ldi r24,lo8(descriptor_list)
 303 009a 90E0      		ldi r25,hi8(descriptor_list)
 304               	.LVL17:
 305               	.L14:
 306               	.LBB42:
 431:usb_mouse.c   **** 				if (desc_val != wValue) {
 307               		.loc 1 431 0
 308 009c FC01      		movw r30,r24
 309               	/* #APP */
 310               	 ;  431 "usb_mouse.c" 1
 311 009e A591      		lpm r26, Z+
 312 00a0 B491      		lpm r27, Z
 313               		
 314               	 ;  0 "" 2
 315               	.LVL18:
 316               	/* #NOAPP */
 317               	.LBE42:
 432:usb_mouse.c   **** 					list += sizeof(struct descriptor_list_struct);
 318               		.loc 1 432 0
 319 00a2 2A17      		cp r18,r26
 320 00a4 3B07      		cpc r19,r27
 321 00a6 01F4      		brne .+2
 322 00a8 00C0      		rjmp .L79
 323               	.LVL19:
 324               	.L72:
 439:usb_mouse.c   **** 					continue;
 325               		.loc 1 439 0
 326 00aa 0796      		adiw r24,7
 327               	.LVL20:
 328 00ac 6150      		subi r22,lo8(-(-1))
 329               	.LVL21:
 427:usb_mouse.c   **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
 330               		.loc 1 427 0
 331 00ae 01F4      		brne .L14
 332               	.LVL22:
 333               	.L13:
 508:usb_mouse.c   **** 			usb_send_in();
 509:usb_mouse.c   **** 			return;
 510:usb_mouse.c   **** 		}
 511:usb_mouse.c   **** 		#ifdef SUPPORT_ENDPOINT_HALT
 512:usb_mouse.c   **** 		if ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)
 513:usb_mouse.c   **** 		  && bmRequestType == 0x02 && wValue == 0) {
 514:usb_mouse.c   **** 			i = wIndex & 0x7F;
 515:usb_mouse.c   **** 			if (i >= 1 && i <= MAX_ENDPOINT) {
 516:usb_mouse.c   **** 				usb_send_in();
 517:usb_mouse.c   **** 				UENUM = i;
 518:usb_mouse.c   **** 				if (bRequest == SET_FEATURE) {
 519:usb_mouse.c   **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);
 520:usb_mouse.c   **** 				} else {
 521:usb_mouse.c   **** 					UECONX = (1<<STALLRQC)|(1<<RSTDT)|(1<<EPEN);
 522:usb_mouse.c   **** 					UERST = (1 << i);
 523:usb_mouse.c   **** 					UERST = 0;
 524:usb_mouse.c   **** 				}
 525:usb_mouse.c   **** 				return;
 526:usb_mouse.c   **** 			}
 527:usb_mouse.c   **** 		}
 528:usb_mouse.c   **** 		#endif
 529:usb_mouse.c   **** 		if (wIndex == MOUSE_INTERFACE) {
 530:usb_mouse.c   **** 			if (bmRequestType == 0xA1) {
 531:usb_mouse.c   **** 				if (bRequest == HID_GET_REPORT) {
 532:usb_mouse.c   **** 					usb_wait_in_ready();
 533:usb_mouse.c   **** 					UEDATX = 0;
 534:usb_mouse.c   **** 					UEDATX = 0;
 535:usb_mouse.c   **** 					UEDATX = 0;
 536:usb_mouse.c   **** 					UEDATX = 0;
 537:usb_mouse.c   **** 					UEDATX = 0;
 538:usb_mouse.c   **** 					UEDATX = 0;
 539:usb_mouse.c   **** 					usb_send_in();
 540:usb_mouse.c   **** 					return;
 541:usb_mouse.c   **** 				}
 542:usb_mouse.c   **** 				if (bRequest == HID_GET_PROTOCOL) {
 543:usb_mouse.c   **** 					usb_wait_in_ready();
 544:usb_mouse.c   **** 					UEDATX = mouse_protocol;
 545:usb_mouse.c   **** 					usb_send_in();
 546:usb_mouse.c   **** 					return;
 547:usb_mouse.c   **** 				}
 548:usb_mouse.c   **** 			}
 549:usb_mouse.c   **** 			if (bmRequestType == 0x21) {
 550:usb_mouse.c   **** 				if (bRequest == HID_SET_PROTOCOL) {
 551:usb_mouse.c   **** 					mouse_protocol = wValue;
 552:usb_mouse.c   **** 					usb_send_in();
 553:usb_mouse.c   **** 					return;
 554:usb_mouse.c   **** 				}
 555:usb_mouse.c   **** 			}
 556:usb_mouse.c   **** 		}
 557:usb_mouse.c   **** 	}
 558:usb_mouse.c   **** 	UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
 334               		.loc 1 558 0
 335 00b0 81E2      		ldi r24,lo8(33)
 336 00b2 8093 EB00 		sts 235,r24
 337               	.L12:
 338               	/* epilogue start */
 559:usb_mouse.c   **** }
 339               		.loc 1 559 0
 340 00b6 FF91      		pop r31
 341 00b8 EF91      		pop r30
 342 00ba CF91      		pop r28
 343 00bc BF91      		pop r27
 344 00be AF91      		pop r26
 345 00c0 9F91      		pop r25
 346 00c2 8F91      		pop r24
 347 00c4 7F91      		pop r23
 348 00c6 6F91      		pop r22
 349 00c8 5F91      		pop r21
 350 00ca 4F91      		pop r20
 351 00cc 3F91      		pop r19
 352 00ce 2F91      		pop r18
 353 00d0 0F90      		pop r0
 354 00d2 0FBE      		out __SREG__,r0
 355 00d4 0F90      		pop r0
 356 00d6 1F90      		pop r1
 357 00d8 1895      		reti
 358               	.LVL23:
 359               	.L76:
 472:usb_mouse.c   **** 			usb_configuration = wValue;
 360               		.loc 1 472 0 discriminator 1
 361 00da 6111      		cpse r22,__zero_reg__
 362 00dc 00C0      		rjmp .L34
 473:usb_mouse.c   **** 			usb_send_in();
 363               		.loc 1 473 0
 364 00de 2093 0000 		sts usb_configuration,r18
 365               	.LBB43:
 366               	.LBB44:
 380:usb_mouse.c   **** }
 367               		.loc 1 380 0
 368 00e2 8EEF      		ldi r24,lo8(-2)
 369               	.LVL24:
 370 00e4 8093 E800 		sts 232,r24
 371               	.LVL25:
 372               	.LBE44:
 373               	.LBE43:
 476:usb_mouse.c   **** 				UENUM = i;
 374               		.loc 1 476 0
 375 00e8 81E0      		ldi r24,lo8(1)
 475:usb_mouse.c   **** 			for (i=1; i<5; i++) {
 376               		.loc 1 475 0
 377 00ea 20E0      		ldi r18,lo8(endpoint_config_table)
 378 00ec 30E0      		ldi r19,hi8(endpoint_config_table)
 379               	.LVL26:
 380               	.L36:
 477:usb_mouse.c   **** 				en = pgm_read_byte(cfg++);
 381               		.loc 1 477 0
 382 00ee 8093 E900 		sts 233,r24
 383               	.LBB45:
 478:usb_mouse.c   **** 				UECONX = en;
 384               		.loc 1 478 0
 385 00f2 A901      		movw r20,r18
 386 00f4 4F5F      		subi r20,-1
 387 00f6 5F4F      		sbci r21,-1
 388               	.LVL27:
 389 00f8 F901      		movw r30,r18
 390               	/* #APP */
 391               	 ;  478 "usb_mouse.c" 1
 392 00fa 9491      		lpm r25, Z
 393               		
 394               	 ;  0 "" 2
 395               	.LVL28:
 396               	/* #NOAPP */
 397               	.LBE45:
 479:usb_mouse.c   **** 				if (en) {
 398               		.loc 1 479 0
 399 00fc 9093 EB00 		sts 235,r25
 480:usb_mouse.c   **** 					UECFG0X = pgm_read_byte(cfg++);
 400               		.loc 1 480 0
 401 0100 9923      		tst r25
 402 0102 01F4      		brne .+2
 403 0104 00C0      		rjmp .L48
 404               	.LVL29:
 405               	.LBB46:
 481:usb_mouse.c   **** 					UECFG1X = pgm_read_byte(cfg++);
 406               		.loc 1 481 0
 407 0106 FA01      		movw r30,r20
 408               	/* #APP */
 409               	 ;  481 "usb_mouse.c" 1
 410 0108 4491      		lpm r20, Z
 411               		
 412               	 ;  0 "" 2
 413               	.LVL30:
 414               	/* #NOAPP */
 415               	.LBE46:
 416 010a 4093 EC00 		sts 236,r20
 417               	.LVL31:
 418               	.LBB47:
 482:usb_mouse.c   **** 				}
 419               		.loc 1 482 0
 420 010e 3196      		adiw r30,1
 421               	.LVL32:
 422               	/* #APP */
 423               	 ;  482 "usb_mouse.c" 1
 424 0110 E491      		lpm r30, Z
 425               		
 426               	 ;  0 "" 2
 427               	.LVL33:
 428               	/* #NOAPP */
 429 0112 2D5F      		subi r18,-3
 430 0114 3F4F      		sbci r19,-1
 431               	.LVL34:
 432               	.LBE47:
 433 0116 E093 ED00 		sts 237,r30
 434               	.LVL35:
 435               	.L35:
 476:usb_mouse.c   **** 				UENUM = i;
 436               		.loc 1 476 0 discriminator 2
 437 011a 8F5F      		subi r24,lo8(-(1))
 438               	.LVL36:
 439 011c 8530      		cpi r24,lo8(5)
 440 011e 01F4      		brne .L36
 485:usb_mouse.c   ****         		UERST = 0;
 441               		.loc 1 485 0
 442 0120 8EE1      		ldi r24,lo8(30)
 443               	.LVL37:
 444 0122 8093 EA00 		sts 234,r24
 486:usb_mouse.c   **** 			return;
 445               		.loc 1 486 0
 446 0126 1092 EA00 		sts 234,__zero_reg__
 487:usb_mouse.c   **** 		}
 447               		.loc 1 487 0
 448 012a 00C0      		rjmp .L12
 449               	.LVL38:
 450               	.L77:
 489:usb_mouse.c   **** 			usb_wait_in_ready();
 451               		.loc 1 489 0 discriminator 1
 452 012c 6038      		cpi r22,lo8(-128)
 453 012e 01F4      		brne .+2
 454 0130 00C0      		rjmp .L38
 455               	.L34:
 529:usb_mouse.c   **** 			if (bmRequestType == 0xA1) {
 456               		.loc 1 529 0
 457 0132 452B      		or r20,r21
 458 0134 01F0      		breq .+2
 459 0136 00C0      		rjmp .L13
 530:usb_mouse.c   **** 				if (bRequest == HID_GET_REPORT) {
 460               		.loc 1 530 0
 461 0138 613A      		cpi r22,lo8(-95)
 462 013a 01F4      		brne .+2
 463 013c 00C0      		rjmp .L80
 549:usb_mouse.c   **** 				if (bRequest == HID_SET_PROTOCOL) {
 464               		.loc 1 549 0
 465 013e 6132      		cpi r22,lo8(33)
 466 0140 01F0      		breq .+2
 467 0142 00C0      		rjmp .L13
 550:usb_mouse.c   **** 					mouse_protocol = wValue;
 468               		.loc 1 550 0
 469 0144 8B30      		cpi r24,lo8(11)
 470 0146 01F0      		breq .+2
 471 0148 00C0      		rjmp .L13
 551:usb_mouse.c   **** 					usb_send_in();
 472               		.loc 1 551 0
 473 014a 2093 0000 		sts mouse_protocol,r18
 474               	.LBB48:
 475               	.LBB49:
 380:usb_mouse.c   **** }
 476               		.loc 1 380 0
 477 014e 8EEF      		ldi r24,lo8(-2)
 478               	.LVL39:
 479 0150 8093 E800 		sts 232,r24
 480 0154 00C0      		rjmp .L12
 481               	.LVL40:
 482               	.L79:
 483               	.LBE49:
 484               	.LBE48:
 436:usb_mouse.c   **** 				desc_val = pgm_read_word(list);
 485               		.loc 1 436 0
 486 0156 FC01      		movw r30,r24
 487 0158 3296      		adiw r30,2
 488               	.LVL41:
 489               	.LBB50:
 437:usb_mouse.c   **** 				if (desc_val != wIndex) {
 490               		.loc 1 437 0
 491               	/* #APP */
 492               	 ;  437 "usb_mouse.c" 1
 493 015a A591      		lpm r26, Z+
 494 015c B491      		lpm r27, Z
 495               		
 496               	 ;  0 "" 2
 497               	.LVL42:
 498               	/* #NOAPP */
 499               	.LBE50:
 438:usb_mouse.c   **** 					list += sizeof(struct descriptor_list_struct)-2;
 500               		.loc 1 438 0
 501 015e 4A17      		cp r20,r26
 502 0160 5B07      		cpc r21,r27
 503 0162 01F0      		breq .+2
 504 0164 00C0      		rjmp .L72
 505               	.LVL43:
 442:usb_mouse.c   **** 				desc_addr = (const uint8_t *)pgm_read_word(list);
 506               		.loc 1 442 0
 507 0166 FC01      		movw r30,r24
 508 0168 3496      		adiw r30,4
 509               	.LVL44:
 443:usb_mouse.c   **** 				list += 2;
 510               		.loc 1 443 0
 511               	/* #APP */
 512               	 ;  443 "usb_mouse.c" 1
 513 016a 4591      		lpm r20, Z+
 514 016c 5491      		lpm r21, Z
 515               		
 516               	 ;  0 "" 2
 517               	.LVL45:
 444:usb_mouse.c   **** 				desc_length = pgm_read_byte(list);
 518               		.loc 1 444 0
 519               	/* #NOAPP */
 520 016e FC01      		movw r30,r24
 521 0170 3696      		adiw r30,6
 522               	.LVL46:
 523               	.LBB51:
 445:usb_mouse.c   **** 				break;
 524               		.loc 1 445 0
 525               	/* #APP */
 526               	 ;  445 "usb_mouse.c" 1
 527 0172 2491      		lpm r18, Z
 528               		
 529               	 ;  0 "" 2
 530               	.LVL47:
 531               	/* #NOAPP */
 532               	.LBE51:
 422:usb_mouse.c   ****                 UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 533               		.loc 1 422 0
 534 0174 872F      		mov r24,r23
 535 0176 90E0      		ldi r25,0
 536 0178 9C2B      		or r25,r28
 448:usb_mouse.c   **** 			if (len > desc_length) len = desc_length;
 537               		.loc 1 448 0
 538 017a 8F3F      		cpi r24,-1
 539 017c 9105      		cpc r25,__zero_reg__
 540 017e 01F0      		breq .+4
 541 0180 00F0      		brlo .+2
 542 0182 00C0      		rjmp .L81
 543               	.L20:
 544               	.LVL48:
 545 0184 8217      		cp r24,r18
 546 0186 00F4      		brsh .+2
 547 0188 00C0      		rjmp .L82
 548               	.LVL49:
 549               	.L21:
 550               	.LBB52:
 551               	.LBB53:
 380:usb_mouse.c   **** }
 552               		.loc 1 380 0
 553 018a 6EEF      		ldi r22,lo8(-2)
 554               	.LVL50:
 555               	.L24:
 556               	.LBE53:
 557               	.LBE52:
 453:usb_mouse.c   **** 				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 558               		.loc 1 453 0 discriminator 1
 559 018c 8091 E800 		lds r24,232
 560               	.LVL51:
 454:usb_mouse.c   **** 				if (i & (1<<RXOUTI)) return;	// abort
 561               		.loc 1 454 0 discriminator 1
 562 0190 982F      		mov r25,r24
 563 0192 9570      		andi r25,lo8(5)
 564 0194 01F0      		breq .L24
 455:usb_mouse.c   **** 				// send IN packet
 565               		.loc 1 455 0
 566 0196 82FD      		sbrc r24,2
 567 0198 00C0      		rjmp .L12
 457:usb_mouse.c   **** 				for (i = n; i; i--) {
 568               		.loc 1 457 0
 569 019a 322F      		mov r19,r18
 570 019c 2132      		cpi r18,lo8(33)
 571 019e 00F0      		brlo .L26
 572 01a0 30E2      		ldi r19,lo8(32)
 573               	.LVL52:
 574               	.L71:
 458:usb_mouse.c   **** 					UEDATX = pgm_read_byte(desc_addr++);
 575               		.loc 1 458 0
 576 01a2 FA01      		movw r30,r20
 577 01a4 832F      		mov r24,r19
 578               	.LVL53:
 579               	.L28:
 580               	.LBB56:
 459:usb_mouse.c   **** 				}
 581               		.loc 1 459 0 discriminator 3
 582               	/* #APP */
 583               	 ;  459 "usb_mouse.c" 1
 584 01a6 9491      		lpm r25, Z
 585               		
 586               	 ;  0 "" 2
 587               	.LVL54:
 588               	/* #NOAPP */
 589               	.LBE56:
 590 01a8 9093 F100 		sts 241,r25
 458:usb_mouse.c   **** 					UEDATX = pgm_read_byte(desc_addr++);
 591               		.loc 1 458 0 discriminator 3
 592 01ac 8150      		subi r24,lo8(-(-1))
 593               	.LVL55:
 594 01ae 3196      		adiw r30,1
 595               	.LVL56:
 596 01b0 8111      		cpse r24,__zero_reg__
 597 01b2 00C0      		rjmp .L28
 598 01b4 8FEF      		ldi r24,lo8(-1)
 599               	.LVL57:
 600 01b6 830F      		add r24,r19
 601 01b8 90E0      		ldi r25,0
 602               	.LVL58:
 603 01ba 0196      		adiw r24,1
 604 01bc 480F      		add r20,r24
 605 01be 591F      		adc r21,r25
 606               	.LVL59:
 461:usb_mouse.c   **** 				usb_send_in();
 607               		.loc 1 461 0
 608 01c0 231B      		sub r18,r19
 609               	.LVL60:
 610               	.LBB57:
 611               	.LBB54:
 380:usb_mouse.c   **** }
 612               		.loc 1 380 0
 613 01c2 6093 E800 		sts 232,r22
 614               	.LVL61:
 615               	.LBE54:
 616               	.LBE57:
 463:usb_mouse.c   **** 			return;
 617               		.loc 1 463 0
 618 01c6 2111      		cpse r18,__zero_reg__
 619 01c8 00C0      		rjmp .L24
 463:usb_mouse.c   **** 			return;
 620               		.loc 1 463 0 is_stmt 0 discriminator 1
 621 01ca 3032      		cpi r19,lo8(32)
 622 01cc 01F0      		breq .L24
 623 01ce 00C0      		rjmp .L12
 624               	.LVL62:
 625               	.L26:
 458:usb_mouse.c   **** 					UEDATX = pgm_read_byte(desc_addr++);
 626               		.loc 1 458 0 is_stmt 1
 627 01d0 2111      		cpse r18,__zero_reg__
 628 01d2 00C0      		rjmp .L71
 629               	.LBB58:
 630               	.LBB55:
 380:usb_mouse.c   **** }
 631               		.loc 1 380 0
 632 01d4 6093 E800 		sts 232,r22
 633 01d8 00C0      		rjmp .L12
 634               	.LVL63:
 635               	.L39:
 636               	.LBE55:
 637               	.LBE58:
 512:usb_mouse.c   **** 		  && bmRequestType == 0x02 && wValue == 0) {
 638               		.loc 1 512 0
 639 01da 982F      		mov r25,r24
 640 01dc 9D7F      		andi r25,lo8(-3)
 641 01de 9130      		cpi r25,lo8(1)
 642 01e0 01F0      		breq .+2
 643 01e2 00C0      		rjmp .L34
 513:usb_mouse.c   **** 			i = wIndex & 0x7F;
 644               		.loc 1 513 0
 645 01e4 6230      		cpi r22,lo8(2)
 646 01e6 01F0      		breq .+2
 647 01e8 00C0      		rjmp .L34
 513:usb_mouse.c   **** 			i = wIndex & 0x7F;
 648               		.loc 1 513 0 is_stmt 0 discriminator 1
 649 01ea 232B      		or r18,r19
 650 01ec 01F0      		breq .+2
 651 01ee 00C0      		rjmp .L13
 514:usb_mouse.c   **** 			if (i >= 1 && i <= MAX_ENDPOINT) {
 652               		.loc 1 514 0 is_stmt 1
 653 01f0 4F77      		andi r20,lo8(127)
 654               	.LVL64:
 515:usb_mouse.c   **** 				usb_send_in();
 655               		.loc 1 515 0
 656 01f2 9FEF      		ldi r25,lo8(-1)
 657 01f4 940F      		add r25,r20
 658 01f6 9430      		cpi r25,lo8(4)
 659 01f8 00F0      		brlo .+2
 660 01fa 00C0      		rjmp .L13
 661               	.LBB59:
 662               	.LBB60:
 380:usb_mouse.c   **** }
 663               		.loc 1 380 0
 664 01fc 9EEF      		ldi r25,lo8(-2)
 665 01fe 9093 E800 		sts 232,r25
 666               	.LBE60:
 667               	.LBE59:
 517:usb_mouse.c   **** 				if (bRequest == SET_FEATURE) {
 668               		.loc 1 517 0
 669 0202 4093 E900 		sts 233,r20
 518:usb_mouse.c   **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);
 670               		.loc 1 518 0
 671 0206 8330      		cpi r24,lo8(3)
 672 0208 01F4      		brne .+2
 673 020a 00C0      		rjmp .L13
 521:usb_mouse.c   **** 					UERST = (1 << i);
 674               		.loc 1 521 0
 675 020c 89E1      		ldi r24,lo8(25)
 676               	.LVL65:
 677 020e 8093 EB00 		sts 235,r24
 522:usb_mouse.c   **** 					UERST = 0;
 678               		.loc 1 522 0
 679 0212 81E0      		ldi r24,lo8(1)
 680 0214 90E0      		ldi r25,0
 681 0216 00C0      		rjmp 2f
 682               		1:
 683 0218 880F      		lsl r24
 684               		2:
 685 021a 4A95      		dec r20
 686 021c 02F4      		brpl 1b
 687 021e 8093 EA00 		sts 234,r24
 523:usb_mouse.c   **** 				}
 688               		.loc 1 523 0
 689 0222 1092 EA00 		sts 234,__zero_reg__
 690 0226 00C0      		rjmp .L12
 691               	.LVL66:
 692               	.L75:
 693               	.LBB61:
 694               	.LBB62:
 380:usb_mouse.c   **** }
 695               		.loc 1 380 0
 696 0228 8EEF      		ldi r24,lo8(-2)
 697               	.LVL67:
 698 022a 8093 E800 		sts 232,r24
 699               	.L32:
 700               	.LBE62:
 701               	.LBE61:
 702               	.LBB63:
 703               	.LBB64:
 376:usb_mouse.c   **** }
 704               		.loc 1 376 0
 705 022e 8091 E800 		lds r24,232
 706 0232 80FF      		sbrs r24,0
 707 0234 00C0      		rjmp .L32
 708               	.LBE64:
 709               	.LBE63:
 469:usb_mouse.c   **** 			return;
 710               		.loc 1 469 0
 711 0236 2068      		ori r18,lo8(-128)
 712               	.LVL68:
 713 0238 2093 E300 		sts 227,r18
 470:usb_mouse.c   **** 		}
 714               		.loc 1 470 0
 715 023c 00C0      		rjmp .L12
 716               	.LVL69:
 717               	.L38:
 718               	.LBB65:
 719               	.LBB66:
 376:usb_mouse.c   **** }
 720               		.loc 1 376 0
 721 023e 8091 E800 		lds r24,232
 722 0242 80FF      		sbrs r24,0
 723 0244 00C0      		rjmp .L38
 724               	.LBE66:
 725               	.LBE65:
 491:usb_mouse.c   **** 			usb_send_in();
 726               		.loc 1 491 0
 727 0246 8091 0000 		lds r24,usb_configuration
 728 024a 8093 F100 		sts 241,r24
 729               	.LBB67:
 730               	.LBB68:
 380:usb_mouse.c   **** }
 731               		.loc 1 380 0
 732 024e 8EEF      		ldi r24,lo8(-2)
 733 0250 8093 E800 		sts 232,r24
 734 0254 00C0      		rjmp .L12
 735               	.LVL70:
 736               	.L82:
 737 0256 282F      		mov r18,r24
 738               	.LVL71:
 739 0258 00C0      		rjmp .L21
 740               	.LVL72:
 741               	.L81:
 742               	.LBE68:
 743               	.LBE67:
 448:usb_mouse.c   **** 			if (len > desc_length) len = desc_length;
 744               		.loc 1 448 0
 745 025a 8FEF      		ldi r24,lo8(-1)
 746 025c 90E0      		ldi r25,0
 747 025e 00C0      		rjmp .L20
 748               	.LVL73:
 749               	.L80:
 531:usb_mouse.c   **** 					usb_wait_in_ready();
 750               		.loc 1 531 0
 751 0260 8130      		cpi r24,lo8(1)
 752 0262 01F0      		breq .L45
 542:usb_mouse.c   **** 					usb_wait_in_ready();
 753               		.loc 1 542 0
 754 0264 8330      		cpi r24,lo8(3)
 755 0266 01F0      		breq .+2
 756 0268 00C0      		rjmp .L13
 757               	.LVL74:
 758               	.L46:
 759               	.LBB69:
 760               	.LBB70:
 376:usb_mouse.c   **** }
 761               		.loc 1 376 0
 762 026a 8091 E800 		lds r24,232
 763 026e 80FF      		sbrs r24,0
 764 0270 00C0      		rjmp .L46
 765               	.LBE70:
 766               	.LBE69:
 544:usb_mouse.c   **** 					usb_send_in();
 767               		.loc 1 544 0
 768 0272 8091 0000 		lds r24,mouse_protocol
 769 0276 8093 F100 		sts 241,r24
 770               	.LBB71:
 771               	.LBB72:
 380:usb_mouse.c   **** }
 772               		.loc 1 380 0
 773 027a 8EEF      		ldi r24,lo8(-2)
 774 027c 8093 E800 		sts 232,r24
 775 0280 00C0      		rjmp .L12
 776               	.L45:
 777               	.LBE72:
 778               	.LBE71:
 779               	.LBB73:
 780               	.LBB74:
 376:usb_mouse.c   **** }
 781               		.loc 1 376 0
 782 0282 8091 E800 		lds r24,232
 783 0286 80FF      		sbrs r24,0
 784 0288 00C0      		rjmp .L45
 785               	.LBE74:
 786               	.LBE73:
 533:usb_mouse.c   **** 					UEDATX = 0;
 787               		.loc 1 533 0
 788 028a 1092 F100 		sts 241,__zero_reg__
 534:usb_mouse.c   **** 					UEDATX = 0;
 789               		.loc 1 534 0
 790 028e 1092 F100 		sts 241,__zero_reg__
 535:usb_mouse.c   **** 					UEDATX = 0;
 791               		.loc 1 535 0
 792 0292 1092 F100 		sts 241,__zero_reg__
 536:usb_mouse.c   **** 					UEDATX = 0;
 793               		.loc 1 536 0
 794 0296 1092 F100 		sts 241,__zero_reg__
 537:usb_mouse.c   **** 					UEDATX = 0;
 795               		.loc 1 537 0
 796 029a 1092 F100 		sts 241,__zero_reg__
 538:usb_mouse.c   **** 					usb_send_in();
 797               		.loc 1 538 0
 798 029e 1092 F100 		sts 241,__zero_reg__
 799               	.LBB75:
 800               	.LBB76:
 380:usb_mouse.c   **** }
 801               		.loc 1 380 0
 802 02a2 8EEF      		ldi r24,lo8(-2)
 803 02a4 8093 E800 		sts 232,r24
 804 02a8 00C0      		rjmp .L12
 805               	.LVL75:
 806               	.L48:
 807               	.LBE76:
 808               	.LBE75:
 809               	.LBB77:
 478:usb_mouse.c   **** 				UECONX = en;
 810               		.loc 1 478 0
 811 02aa 9A01      		movw r18,r20
 812               	.LVL76:
 813 02ac 00C0      		rjmp .L35
 814               	.LVL77:
 815               	.L78:
 816               	.LBE77:
 501:usb_mouse.c   **** 				if (UECONX & (1<<STALLRQ)) i = 1;
 817               		.loc 1 501 0
 818 02ae 4093 E900 		sts 233,r20
 502:usb_mouse.c   **** 				UENUM = 0;
 819               		.loc 1 502 0
 820 02b2 8091 EB00 		lds r24,235
 821 02b6 85FB      		bst r24,5
 822 02b8 8827      		clr r24
 823 02ba 80F9      		bld r24,0
 824               	.LVL78:
 503:usb_mouse.c   **** 			}
 825               		.loc 1 503 0
 826 02bc 1092 E900 		sts 233,__zero_reg__
 827 02c0 00C0      		rjmp .L41
 828               		.cfi_endproc
 829               	.LFE8:
 831               		.data
 834               	mouse_protocol:
 835 0000 01        		.byte	1
 836               		.local	usb_configuration
 837               		.comm	usb_configuration,1,1
 838               		.section	.progmem.data,"a",@progbits
 841               	descriptor_list:
 842 0000 0001      		.word	256
 843 0002 0000      		.word	0
 844 0004 0000      		.word	device_descriptor
 845 0006 12        		.byte	18
 846 0007 0002      		.word	512
 847 0009 0000      		.word	0
 848 000b 0000      		.word	config1_descriptor
 849 000d 22        		.byte	34
 850 000e 0022      		.word	8704
 851 0010 0000      		.word	0
 852 0012 0000      		.word	mouse_hid_report_desc
 853 0014 45        		.byte	69
 854 0015 0021      		.word	8448
 855 0017 0000      		.word	0
 856 0019 0000      		.word	config1_descriptor+18
 857 001b 09        		.byte	9
 858 001c 0003      		.word	768
 859 001e 0000      		.word	0
 860 0020 0000      		.word	string0
 861 0022 04        		.byte	4
 862 0023 0103      		.word	769
 863 0025 0904      		.word	1033
 864 0027 0000      		.word	string1
 865 0029 08        		.byte	8
 866 002a 0203      		.word	770
 867 002c 0904      		.word	1033
 868 002e 0000      		.word	string2
 869 0030 0E        		.byte	14
 872               	string2:
 873 0031 0E        		.byte	14
 874 0032 03        		.byte	3
 875 0033 5000      		.string	"P"
 876 0035 7500      		.string	"u"
 877 0037 6200      		.string	"b"
 878 0039 6C00      		.string	"l"
 879 003b 6900      		.string	"i"
 880 003d 6300      		.string	"c"
 881 003f 00        		.string	""
 882 0040 00        		.string	""
 885               	string1:
 886 0041 08        		.byte	8
 887 0042 03        		.byte	3
 888 0043 4200      		.string	"B"
 889 0045 7300      		.string	"s"
 890 0047 7400      		.string	"t"
 891 0049 00        		.string	""
 892 004a 00        		.string	""
 895               	string0:
 896 004b 04        		.byte	4
 897 004c 03        		.byte	3
 898 004d 0904      		.word	1033
 901               	config1_descriptor:
 902 004f 09        		.byte	9
 903 0050 02        		.byte	2
 904 0051 22        		.byte	34
 905 0052 00        		.byte	0
 906 0053 01        		.byte	1
 907 0054 01        		.byte	1
 908 0055 00        		.byte	0
 909 0056 C0        		.byte	-64
 910 0057 32        		.byte	50
 911 0058 09        		.byte	9
 912 0059 04        		.byte	4
 913 005a 00        		.byte	0
 914 005b 00        		.byte	0
 915 005c 01        		.byte	1
 916 005d 03        		.byte	3
 917 005e 01        		.byte	1
 918 005f 02        		.byte	2
 919 0060 00        		.byte	0
 920 0061 09        		.byte	9
 921 0062 21        		.byte	33
 922 0063 11        		.byte	17
 923 0064 01        		.byte	1
 924 0065 00        		.byte	0
 925 0066 01        		.byte	1
 926 0067 22        		.byte	34
 927 0068 45        		.byte	69
 928 0069 00        		.byte	0
 929 006a 07        		.byte	7
 930 006b 05        		.byte	5
 931 006c 83        		.byte	-125
 932 006d 03        		.byte	3
 933 006e 06        		.byte	6
 934 006f 00        		.byte	0
 935 0070 01        		.byte	1
 938               	mouse_hid_report_desc:
 939 0071 05        		.byte	5
 940 0072 01        		.byte	1
 941 0073 09        		.byte	9
 942 0074 02        		.byte	2
 943 0075 A1        		.byte	-95
 944 0076 01        		.byte	1
 945 0077 05        		.byte	5
 946 0078 09        		.byte	9
 947 0079 19        		.byte	25
 948 007a 01        		.byte	1
 949 007b 29        		.byte	41
 950 007c 05        		.byte	5
 951 007d 15        		.byte	21
 952 007e 00        		.byte	0
 953 007f 25        		.byte	37
 954 0080 01        		.byte	1
 955 0081 95        		.byte	-107
 956 0082 05        		.byte	5
 957 0083 75        		.byte	117
 958 0084 01        		.byte	1
 959 0085 81        		.byte	-127
 960 0086 02        		.byte	2
 961 0087 95        		.byte	-107
 962 0088 01        		.byte	1
 963 0089 75        		.byte	117
 964 008a 03        		.byte	3
 965 008b 81        		.byte	-127
 966 008c 03        		.byte	3
 967 008d 05        		.byte	5
 968 008e 01        		.byte	1
 969 008f 09        		.byte	9
 970 0090 30        		.byte	48
 971 0091 09        		.byte	9
 972 0092 31        		.byte	49
 973 0093 16        		.byte	22
 974 0094 01        		.byte	1
 975 0095 80        		.byte	-128
 976 0096 26        		.byte	38
 977 0097 FF        		.byte	-1
 978 0098 7F        		.byte	127
 979 0099 36        		.byte	54
 980 009a 01        		.byte	1
 981 009b 80        		.byte	-128
 982 009c 46        		.byte	70
 983 009d FF        		.byte	-1
 984 009e 7F        		.byte	127
 985 009f 75        		.byte	117
 986 00a0 10        		.byte	16
 987 00a1 95        		.byte	-107
 988 00a2 02        		.byte	2
 989 00a3 81        		.byte	-127
 990 00a4 06        		.byte	6
 991 00a5 09        		.byte	9
 992 00a6 38        		.byte	56
 993 00a7 15        		.byte	21
 994 00a8 81        		.byte	-127
 995 00a9 25        		.byte	37
 996 00aa 7F        		.byte	127
 997 00ab 35        		.byte	53
 998 00ac 81        		.byte	-127
 999 00ad 45        		.byte	69
 1000 00ae 7F        		.byte	127
 1001 00af 75        		.byte	117
 1002 00b0 08        		.byte	8
 1003 00b1 95        		.byte	-107
 1004 00b2 01        		.byte	1
 1005 00b3 81        		.byte	-127
 1006 00b4 06        		.byte	6
 1007 00b5 C0        		.byte	-64
 1010               	device_descriptor:
 1011 00b6 12        		.byte	18
 1012 00b7 01        		.byte	1
 1013 00b8 00        		.byte	0
 1014 00b9 02        		.byte	2
 1015 00ba 00        		.byte	0
 1016 00bb 00        		.byte	0
 1017 00bc 00        		.byte	0
 1018 00bd 20        		.byte	32
 1019 00be C0        		.byte	-64
 1020 00bf 16        		.byte	22
 1021 00c0 7E        		.byte	126
 1022 00c1 04        		.byte	4
 1023 00c2 00        		.byte	0
 1024 00c3 01        		.byte	1
 1025 00c4 01        		.byte	1
 1026 00c5 02        		.byte	2
 1027 00c6 00        		.byte	0
 1028 00c7 01        		.byte	1
 1031               	endpoint_config_table:
 1032 00c8 00        		.byte	0
 1033 00c9 00        		.byte	0
 1034 00ca 01        		.byte	1
 1035 00cb C1        		.byte	-63
 1036 00cc 02        		.byte	2
 1037 00cd 00        		.byte	0
 1038               		.text
 1039               	.Letext0:
 1040               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb_mouse.c
     /tmp/cc2RfrCb.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc2RfrCb.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc2RfrCb.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc2RfrCb.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc2RfrCb.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc2RfrCb.s:13     .text.usb_init:0000000000000000 usb_init
                             .bss:0000000000000000 usb_configuration
     /tmp/cc2RfrCb.s:59     .text.usb_configured:0000000000000000 usb_configured
     /tmp/cc2RfrCb.s:77     .text.__vector_10:0000000000000000 __vector_10
     /tmp/cc2RfrCb.s:139    .text.__vector_11:0000000000000000 __vector_11
     /tmp/cc2RfrCb.s:841    .progmem.data:0000000000000000 descriptor_list
     /tmp/cc2RfrCb.s:1031   .progmem.data:00000000000000c8 endpoint_config_table
     /tmp/cc2RfrCb.s:834    .data:0000000000000000 mouse_protocol
     /tmp/cc2RfrCb.s:1010   .progmem.data:00000000000000b6 device_descriptor
     /tmp/cc2RfrCb.s:901    .progmem.data:000000000000004f config1_descriptor
     /tmp/cc2RfrCb.s:938    .progmem.data:0000000000000071 mouse_hid_report_desc
     /tmp/cc2RfrCb.s:895    .progmem.data:000000000000004b string0
     /tmp/cc2RfrCb.s:885    .progmem.data:0000000000000041 string1
     /tmp/cc2RfrCb.s:872    .progmem.data:0000000000000031 string2

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
